package com.zishanfu.geosparksim.Generation;

import com.vividsolutions.jts.geom.Coordinate;
import com.zishanfu.geosparksim.Model.Vehicle;
import com.zishanfu.geosparksim.ShortestPath.Graph;
import com.zishanfu.geosparksim.Tools.SpatialRandom;


public class Generation {

    /**
     * Vehicle source and destination randomly generated by the boundary and travel length
     * Simulation information
     *
     * @param minLon the minimum longitude
     * @param minLat the minimum latitude
     * @param maxLon the maximum longitude
     * @param maxLat the maximum latitude
     * @param graph the routing graph
     * @param maxLen defined maximum vehicle travel length
     * @param type vehicle generation type
     * @param total the number of vehicles
     * @return a list of vehicles
     */
    public Vehicle[] vehicleGeneration(double minLon, double minLat, double maxLon, double maxLat, Graph graph, double maxLen, String type, int total) {

        SpatialRandom spatialRand = new SpatialRandom( minLon, minLat, maxLon, maxLat, maxLen, graph);
        Vehicle[] vehicles = new Vehicle[total];

        for(int i = 0; i<total; i++) {
            vehicles[i] = computeVehicle(type, spatialRand, i, graph);
        }

        return vehicles;
    }

    private Vehicle computeVehicle(String type, SpatialRandom rand, int sid, Graph graph){
        double len = rand.spatialRandomLen();
        Coordinate src = null;
        Coordinate dest = null;
        if(type.contains("DSO")) {
            src = rand.spatialRandomNode();
            dest = rand.computeDestDSO(src, len);
        }else if(type.contains("NB")) {
            src = rand.computeSourceNB();
            dest = rand.computeDestinationNB(src, len);
        }

        Vehicle vehicle = graph.request(src, dest);

        //recompute to meet the total requests
        if(vehicle == null) {
            return computeVehicle(type, rand, sid, graph);
        }

        Long[] path = vehicle.getEdgePath();
        if(path == null || path.length <= 1) {
            return computeVehicle(type, rand, sid, graph);
        }

        return vehicle;
    }
}
